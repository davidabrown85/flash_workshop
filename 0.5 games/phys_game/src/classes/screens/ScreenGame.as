package classes.screens{			import Box2D.Dynamics.*;	import Box2D.Collision.*;	import Box2D.Collision.Shapes.*;	import Box2D.Common.Math.*;	import Box2D.Dynamics.Joints.*;		import classes.physics.*;	import classes.Main;					import flash.display.Sprite;	import flash.display.Loader;	import flash.display.MovieClip;	import flash.events.MouseEvent;	import flash.events.Event;		import flash.net.URLRequest;	import flash.events.IOErrorEvent;	import flash.events.ProgressEvent;  	import flash.events.KeyboardEvent;	import flash.ui.Keyboard; 	public class ScreenGame extends MovieClip 	{		private var world:b2World;		private var iterations:int = 10;		private var physics_scale:int = 30;		private const PI:Number = 180 / Math.PI;		private var time_step:Number = 1.0 / physics_scale;				private var box2D_graphics:MovieClip;						private var mousePVec:b2Vec2 = new b2Vec2();		private var mouseJoint:b2MouseJoint;		private var mouse_world_x:Number;		private var mouse_world_y:Number;				private var the_level:MovieClip;				private var mainClass:Main;				private var swf_loader:Loader = new Loader();				private var theKeyUp:Boolean = false;		private var theKeyDown:Boolean = false;		private var theKeyLeft:Boolean = false;		private var theKeyRight:Boolean = false;		private var theKeySpace:Boolean = false;				private var player_phy:b2Body;		private var player_mc:MovieClip;				private const SIDE_FORCE:int = 1;		private const JUMP_FORCE:int = 15;		private const MAX_SPEED:int = 15;				private var p_jumping:Boolean = false;		private var whichAnim:String = "";		private var tempAnim:String = "";				/**		 * app constructor, should not be treated as the application entry point.		 * A listener is registered if the holder is present, otherwise it will trigger		 * init() for local development		 */		public function ScreenGame() { }								public function init( holder_mc:Main ):void		{			mainClass = holder_mc;						load_level( "levelSWF/DemoLevel.swf" );		}								private function load_level( swf_path:String ):void		{						swf_loader = new Loader();			swf_loader.contentLoaderInfo.addEventListener( ProgressEvent.PROGRESS, progress_handler );			swf_loader.contentLoaderInfo.addEventListener( IOErrorEvent.IO_ERROR, load_error );			swf_loader.contentLoaderInfo.addEventListener( Event.COMPLETE, load_complete );			swf_loader.load( new URLRequest( swf_path ) );		}								private function progress_handler( ev:ProgressEvent ):void		{			//var percLoaded:Number = ( ev.bytesLoaded / ev.bytesTotal );        }				private function load_error( ev:IOErrorEvent ):void 		{			//trace( "The following error occured: " + ev );   		}									private function load_complete( ev:Event ):void		{			swf_loader.removeEventListener( ProgressEvent.PROGRESS, progress_handler );			swf_loader.removeEventListener( IOErrorEvent.IO_ERROR, load_error );			swf_loader.removeEventListener( Event.COMPLETE, load_complete );						the_level = ev.currentTarget.content as MovieClip;						addChild( the_level );						setup_box2D( );		}								/**		 * Hide the menu systems and setup the box2D world		 * Create the character and add the level graphics and start the clock		 *		**/				private function setup_box2D( ):void		{						world = new b2World( new b2Vec2( 0, 30.0 ), true );						var contact_listener:ContactListener = new ContactListener( );			contact_listener.setup_listeners( this );			world.SetContactListener( contact_listener );						setup_debug( );						create_level( );						stage.addEventListener( KeyboardEvent.KEY_DOWN, KeyDown );			stage.addEventListener( KeyboardEvent.KEY_UP,   KeyUp   );						stage.addEventListener( MouseEvent.MOUSE_DOWN, on_mouse_down );			stage.addEventListener( MouseEvent.MOUSE_UP, on_mouse_up );					}								private function setup_debug( ):void		{				var dbgDraw:b2DebugDraw = new b2DebugDraw();			var dbgSprite:Sprite = new Sprite();						var box2D_graphics:Sprite = new Sprite();			box2D_graphics.addChild( dbgSprite );			the_level.addChild( box2D_graphics );			dbgDraw.SetSprite( box2D_graphics );			dbgDraw.SetDrawScale( 30 );			dbgDraw.SetAlpha( 1 );			dbgDraw.SetFillAlpha( 0.5 );			dbgDraw.SetLineThickness( 1 );			dbgDraw.SetFlags( b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit );			world.SetDebugDraw(dbgDraw);		}  		/**		 * check every movieclip in the physics container and if there is a marker attached to the movieclip then create the object		 * specialObjects are items with an enterframe function and objects in the needsDestroyArray needs to be manually removed at the end of the level		 *		**/		private function create_level( ):void		{			var phys_object:Physics_Object = new Physics_Object( );			phys_object.setup_physics( world, physics_scale );						var object_amount:int = the_level.numChildren;						var new_object:* = new MovieClip();						for( var i:int; i < object_amount; i++ )			{				new_object = the_level.getChildAt( i );								if( new_object is MovieClip && new_object.hasOwnProperty( "object_type" ) )				{					new_object.create_object( );										if( new_object.object_type == "player_mc" )					{						player_phy = new_object.body;						player_mc = player_phy.GetUserData().texture;					}				}			}						start_update();		}								/**		 * If you want mouse interaction		**/		private function update_mouse( ev:MouseEvent ):void		{			if ( mouseJoint ) 			{				mouse_world_x = mouseX / physics_scale;				mouse_world_y = mouseY / physics_scale;								var p2:b2Vec2 = new b2Vec2( mouse_world_x, mouse_world_y );				mouseJoint.SetTarget( p2 );			}		}								private function on_mouse_down( ev:MouseEvent ):void 		{			stage.addEventListener( MouseEvent.MOUSE_MOVE, update_mouse );						mouse_world_x = mouseX / physics_scale;			mouse_world_y = mouseY / physics_scale;							var body:b2Body = GetBodyAtMouse();						if ( body ) 			{				var mouse_joint:b2MouseJointDef = new b2MouseJointDef;				mouse_joint.bodyA = world.GetGroundBody();				mouse_joint.bodyB = body;				mouse_joint.target.Set( mouse_world_x, mouse_world_y );				mouse_joint.collideConnected = true;				mouse_joint.maxForce = 500.0 * body.GetMass();				mouseJoint = world.CreateJoint( mouse_joint ) as b2MouseJoint;				body.SetAwake( true );			}		}								private function on_mouse_up( ev:MouseEvent ):void 		{			if ( mouseJoint )			{				stage.removeEventListener( MouseEvent.MOUSE_MOVE, update_mouse );								world.DestroyJoint( mouseJoint );				mouseJoint = null;			}		}								public function GetBodyAtMouse( include_static:Boolean = false ):b2Body 		{			mousePVec.Set( mouse_world_x, mouse_world_y );						var aabb:b2AABB = new b2AABB();			aabb.lowerBound.Set( mouse_world_x - 0.001, mouse_world_y - 0.001 );			aabb.upperBound.Set( mouse_world_x + 0.001, mouse_world_y + 0.001 );						var body:b2Body = null;						function GetBodyCallback( fixture:b2Fixture ):Boolean			{				var shape:b2Shape = fixture.GetShape();								if (fixture.GetBody().GetType() != b2Body.b2_staticBody || include_static)				{					var inside:Boolean = shape.TestPoint( fixture.GetBody().GetTransform(), mousePVec );					if( inside )					{						body = fixture.GetBody();						return false;					}				}				return true;			}						world.QueryAABB( GetBodyCallback, aabb );						return body;		}								public function GetBodyAtPoint( the_x:int, the_y:int, include_static:Boolean = false ):b2Body 		{			var pointPVec:b2Vec2 = new b2Vec2( the_x, the_y );						var aabb:b2AABB = new b2AABB();			aabb.lowerBound.Set( the_x - 0.001, the_y - 0.001 );			aabb.upperBound.Set( the_x + 0.001, the_y + 0.001 );						var body:b2Body = null;						function GetBodyCallback( fixture:b2Fixture ):Boolean			{				var shape:b2Shape = fixture.GetShape();								if (fixture.GetBody().GetType() != b2Body.b2_staticBody || include_static)				{					var inside:Boolean = shape.TestPoint( fixture.GetBody().GetTransform(), pointPVec );					if( inside )					{						body = fixture.GetBody();						return false;					}				}				return true;			}						world.QueryAABB( GetBodyCallback, aabb );						return body;		}						private function start_update():void { addEventListener(Event.ENTER_FRAME, update, false, 0, true); }		private function stop_update():void  { removeEventListener(Event.ENTER_FRAME, update); }										private function KeyDown( e:KeyboardEvent ) 		{						switch (e.keyCode) 			{				case Keyboard.LEFT  : theKeyLeft  = true; break;				case Keyboard.RIGHT : theKeyRight = true; break;				case Keyboard.UP    : theKeyUp    = true; break;				case Keyboard.DOWN  : theKeyDown  = true; break;				case Keyboard.SPACE : theKeySpace = true; break;			}		}				private function KeyUp( e:KeyboardEvent ) 		{					switch (e.keyCode) 			{				case Keyboard.LEFT  : theKeyLeft  = false; break;				case Keyboard.RIGHT : theKeyRight = false; break;				case Keyboard.UP    : theKeyUp    = false; break;				case Keyboard.DOWN  : theKeyDown  = false; break;				case Keyboard.SPACE : theKeySpace = false; break; 			}		}								/**		 * On Enter_Frame update the characters position and calculate the level gravity		 *		**/		private function update( ev:Event ):void 		{			world.Step( time_step, iterations, iterations );			world.DrawDebugData();			world.ClearForces() ;			for ( var bb:b2Body = world.GetBodyList(); bb; bb = bb.GetNext() )			{				if ( bb.GetUserData() && bb.GetUserData().texture )//.texture is MovieClip || bb.GetUserData().texture is Sprite  )				{					var phys_mc:MovieClip = bb.GetUserData().texture as MovieClip;					phys_mc.x = bb.GetPosition().x * physics_scale;					phys_mc.y = bb.GetPosition().y * physics_scale;					phys_mc.rotation = bb.GetAngle() * PI;									if( bb.GetUserData().status == "remove" )					{						bb.GetUserData().texture.visible = false;						world.DestroyBody( bb );										}				}			}						update_movement();			update_anim();			update_position();		}						private function update_movement():void		{			if (theKeyLeft)  			{ 				player_phy.SetAwake( true ); 								if( player_phy.GetPosition().x > ( player_mc.width / 2 ) / physics_scale && player_phy.GetLinearVelocity().x > -MAX_SPEED )				{					player_phy.ApplyImpulse( new b2Vec2( -SIDE_FORCE, 0 ),  player_phy.GetLocalCenter() );					trace(player_phy.GetLinearVelocity().x);				}			}			if (theKeyRight) 			{ 				player_phy.SetAwake( true ); 												if( player_phy.GetPosition().x < ( the_level.width - ( player_mc.width / 2 ) ) / physics_scale && player_phy.GetLinearVelocity().x < MAX_SPEED )					player_phy.ApplyImpulse( new b2Vec2( SIDE_FORCE, 0 ),  player_phy.GetLocalCenter() );			}						if ( theKeyUp || theKeySpace ) 			{						theKeyUp = theKeySpace = false;							if( !p_jumping )				{					player_phy.ApplyImpulse( new b2Vec2( 0, -JUMP_FORCE ),  player_phy.GetLocalCenter() );									p_jumping = true;				}			}		}				private function update_anim():void		{							if( p_jumping )			{				if( player_phy.GetLinearVelocity().x > 1 && player_phy.GetLinearVelocity().x <= 5 && tempAnim != "running_jump_right" ) 					whichAnim = "standing_jump_right";				else if( tempAnim == "running_jump_right" &&  player_phy.GetLinearVelocity().y > 1) 					whichAnim = "running_fall_right";				else if( player_phy.GetLinearVelocity().x > 5 && tempAnim != "running_fall_right" ) 					whichAnim = "running_jump_right";								else if( player_phy.GetLinearVelocity().x < -1 && player_phy.GetLinearVelocity().x >= -5 && tempAnim != "running_jump_left" ) 					whichAnim = "standing_jump_left";				else if( tempAnim == "running_jump_left" &&  player_phy.GetLinearVelocity().y > 2) 					whichAnim = "running_fall_left";				else if( player_phy.GetLinearVelocity().x < -5 && tempAnim != "running_fall_left" ) 					whichAnim = "running_jump_left";											else if( tempAnim == "static" && player_phy.GetLinearVelocity().y < -1 ) 					whichAnim = "standing_jump_right";				else if( tempAnim == "static" && player_phy.GetLinearVelocity().y < -1 ) 					whichAnim = "standing_jump_left";			}			else			{				if( player_phy.GetLinearVelocity().x > 1 && player_phy.GetLinearVelocity().x <= 5 ) 					whichAnim = "walk_right";				else if( player_phy.GetLinearVelocity().x > 5 && player_phy.GetLinearVelocity().y > 1) 					whichAnim = "running_fall_right";				else if( player_phy.GetLinearVelocity().x > 5 ) 					whichAnim = "run_right";								else if( player_phy.GetLinearVelocity().x < -1 && player_phy.GetLinearVelocity().x >= -5 ) 					whichAnim = "walk_left";				else if( player_phy.GetLinearVelocity().x < -5 && player_phy.GetLinearVelocity().y > 2) 					whichAnim = "running_fall_left";				else if( player_phy.GetLinearVelocity().x < -5 ) 					whichAnim = "run_left";								else if( whichAnim == "walk_left" || whichAnim == "run_left" || whichAnim == "walk_right" || whichAnim == "run_right" )					whichAnim = "static";				}						if( whichAnim != tempAnim ) 			{ 				player_mc.getChildAt(0).gotoAndStop( whichAnim ); 				tempAnim = whichAnim; 			}		}						private function update_position( ):void		{			if( player_mc && the_level )			{				var world_shift_x:int = ( -player_mc.x + ( stage.stageWidth / 2 ) );				var world_shift_y:int = ( -player_mc.y + ( stage.stageHeight / 2 ) );					if ( world_shift_x > 0 )					world_shift_x = 0;								else if ( world_shift_x < -the_level.width + stage.stageWidth )					world_shift_x = -the_level.width + stage.stageWidth;											//if ( world_shift_y > 0 )				//	world_shift_y = 0;								//else if ( world_shift_y < -the_level.height + stage.stageHeight )				//	world_shift_y = -the_level.height + stage.stageHeight;								the_level.x = world_shift_x;				the_level.y = world_shift_y;			}		}						public function player_landed():void		{			p_jumping = false;			player_mc.getChildAt(0).gotoAndStop( "static" ); 		}						public function setup_text( theXML:XML, lang:String ):void		{			//game_btn.btn_txt.text = theXML..do_not_push_btn;		}						public function game_over( ):void		{			mainClass.change_screen( ScreenConstants.SCREEN_END );			}						public function clean_up():void		{			stop_update();						stage.removeEventListener( MouseEvent.MOUSE_DOWN, on_mouse_down );			stage.removeEventListener( MouseEvent.MOUSE_UP, on_mouse_up );			stage.removeEventListener( MouseEvent.MOUSE_MOVE, update_mouse );						swf_loader.removeEventListener( ProgressEvent.PROGRESS, progress_handler );			swf_loader.removeEventListener( IOErrorEvent.IO_ERROR, load_error );			swf_loader.removeEventListener( Event.COMPLETE, load_complete );		}	}}