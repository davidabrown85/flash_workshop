package classes{			import Box2D.Dynamics.*;	import Box2D.Collision.*;	import Box2D.Collision.Shapes.*;	import Box2D.Common.Math.*;	import Box2D.Dynamics.Joints.*;		import classes.LevelObjects.*;					import flash.display.Sprite;	import flash.display.Loader;	import flash.display.MovieClip;	import flash.events.MouseEvent;	import flash.events.Event;		import flash.net.URLRequest;	import flash.events.IOErrorEvent;	import flash.events.ProgressEvent;  	public class Box2DSetup extends MovieClip 	{		private var world:b2World;		private var iterations:int = 10;		private var physics_scale:int = 30;		private var time_step:Number = 1.0 / physics_scale;				private var box2D_graphics:MovieClip;				private var ball_object:Object = new Object();				private var mousePVec:b2Vec2 = new b2Vec2();		private var mouse_world_x:Number;		private var mouse_world_y:Number;		private var mouseJoint:b2MouseJoint;				private var the_level:MovieClip;						/**		 * app constructor, should not be treated as the application entry point.		 * A listener is registered if the holder is present, otherwise it will trigger		 * init() for local development		 */		public function Box2DSetup() { init(); }								public function init():void		{			load_level( "levelSWF/DemoLevel.swf" );		}								private function load_level( swf_path:String ):void		{						var swf_loader:Loader = new Loader();			swf_loader.contentLoaderInfo.addEventListener( ProgressEvent.PROGRESS, progress_handler );			swf_loader.contentLoaderInfo.addEventListener( IOErrorEvent.IO_ERROR, load_error );			swf_loader.contentLoaderInfo.addEventListener( Event.COMPLETE, load_complete );			swf_loader.load( new URLRequest( swf_path ) );		}								private function progress_handler( ev:ProgressEvent ):void		{			var percLoaded:Number = ( ev.bytesLoaded / ev.bytesTotal );        }				private function load_error( ev:IOErrorEvent ):void 		{			trace( "The following error occured: " + ev );   		}									private function load_complete( ev:Event ):void		{			ev.currentTarget.removeEventListener( ProgressEvent.PROGRESS, progress_handler );			ev.currentTarget.removeEventListener( IOErrorEvent.IO_ERROR, load_error );			ev.currentTarget.removeEventListener( Event.COMPLETE, load_complete );						the_level = ev.currentTarget.content as MovieClip;						addChild( the_level );						setup_box2D( );		}								/**		 * Hide the menu systems and setup the box2D world		 * Create the character and add the level graphics and start the clock		 *		**/				private function setup_box2D( ):void		{					box2D_graphics = new MovieClip();			addChild( box2D_graphics );						world = new b2World( new b2Vec2(0,30.0), true );			//world.SetContactListener( new b2ContactListener( this ) );						setup_debug( );						create_level( );						stage.addEventListener(MouseEvent.MOUSE_DOWN, on_mouse_down);			stage.addEventListener(MouseEvent.MOUSE_UP, on_mouse_up);					}								private function setup_debug( ):void		{						var dbgDraw:b2DebugDraw = new b2DebugDraw();			var dbgSprite:Sprite = new Sprite();						box2D_graphics.addChild( dbgSprite );			dbgDraw.SetSprite( box2D_graphics );			dbgDraw.SetDrawScale( 30 );			dbgDraw.SetAlpha( 1 );			dbgDraw.SetFillAlpha( 0.5 );			dbgDraw.SetLineThickness( 1 );			dbgDraw.SetFlags( b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit );			world.SetDebugDraw(dbgDraw);		}  		/**		 * check every movieclip in the physics container and if there is a marker attached to the movieclip then create the object		 * specialObjects are items with an enterframe function and objects in the needsDestroyArray needs to be manually removed at the end of the level		 *		**/		private function create_level( ):void		{			var phys_object:Physics_Object = new Physics_Object( );			phys_object.setup_physics( world, physics_scale );						var object_amount:int = the_level.numChildren;						var new_object:* = new MovieClip();						for( var i:int; i < object_amount; i++ )			{				new_object = the_level.getChildAt( i );								if( new_object is MovieClip && new_object.hasOwnProperty( "object_type" ) )				{					if( new_object.object_type == "foot_ball_mc" )					{						ball_object = new_object.create_object(  );					}					else					{						new_object.create_object( );					}				}			}						start_update();		}										private function update_mouse( ev:MouseEvent ):void		{			if ( mouseJoint ) 			{				mouse_world_x = mouseX / physics_scale;				mouse_world_y = mouseY / physics_scale;								var p2:b2Vec2 = new b2Vec2( mouse_world_x, mouse_world_y );				mouseJoint.SetTarget( p2 );			}		}								private function on_mouse_down( ev:MouseEvent ):void 		{			stage.addEventListener( MouseEvent.MOUSE_MOVE, update_mouse );						mouse_world_x = mouseX / physics_scale;			mouse_world_y = mouseY / physics_scale;							var body:b2Body = GetBodyAtMouse();						if ( body ) 			{				var mouse_joint:b2MouseJointDef = new b2MouseJointDef;				mouse_joint.bodyA = world.GetGroundBody();				mouse_joint.bodyB = body;				mouse_joint.target.Set( mouse_world_x, mouse_world_y );				mouse_joint.collideConnected = true;				mouse_joint.maxForce = 500.0 * body.GetMass();				mouseJoint = world.CreateJoint( mouse_joint ) as b2MouseJoint;				body.SetAwake( true );			}		}								private function on_mouse_up( ev:MouseEvent ):void 		{			if ( mouseJoint )			{				stage.removeEventListener( MouseEvent.MOUSE_MOVE, update_mouse );								world.DestroyJoint( mouseJoint );				mouseJoint = null;			}		}								public function GetBodyAtMouse( include_static:Boolean = false ):b2Body 		{			mousePVec.Set( mouse_world_x, mouse_world_y );						var aabb:b2AABB = new b2AABB();			aabb.lowerBound.Set( mouse_world_x - 0.001, mouse_world_y - 0.001 );			aabb.upperBound.Set( mouse_world_x + 0.001, mouse_world_y + 0.001 );						var body:b2Body = null;						function GetBodyCallback( fixture:b2Fixture ):Boolean			{				var shape:b2Shape = fixture.GetShape();								if (fixture.GetBody().GetType() != b2Body.b2_staticBody || include_static)				{					var inside:Boolean = shape.TestPoint( fixture.GetBody().GetTransform(), mousePVec );					if( inside )					{						body = fixture.GetBody();						return false;					}				}				return true;			}						world.QueryAABB( GetBodyCallback, aabb );						return body;		}				private function start_update():void { addEventListener(Event.ENTER_FRAME, update, false, 0, true); }		private function stop_update():void  { removeEventListener(Event.ENTER_FRAME, update); }										/**		 * On Enter_Frame update the characters position and calculate the level gravity		 *		**/		private function update( ev:Event ):void 		{			world.Step( time_step, iterations, iterations );			//world.DrawDebugData();			world.ClearForces() ;			ball_object.fixture.userData.x = ball_object.body.GetPosition().x * physics_scale;			ball_object.fixture.userData.y = ball_object.body.GetPosition().y * physics_scale;			ball_object.fixture.userData.rotation = ball_object.body.GetAngle() * ( 180 / Math.PI );		}	}}